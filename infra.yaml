AWSTemplateFormatVersion: '2010-09-09'

Description: Three Tier Architecture with VPC, Subnets, NAT, IGW, Route Tables, Security Groups, IAM, EKS Cluster, NodeGroup, and aws-auth ConfigMap for multi-user access

Parameters:
  VpcCIDR:
    Type: String
    Default: 10.0.0.0/16

  PublicSubnet1CIDR:
    Type: String
    Default: 10.0.1.0/24

  PublicSubnet2CIDR:
    Type: String
    Default: 10.0.2.0/24

  PrivateSubnet1CIDR:
    Type: String
    Default: 10.0.3.0/24

  PrivateSubnet2CIDR:
    Type: String
    Default: 10.0.4.0/24

  ClusterName:
    Type: String
    Default: my-eks-cluster

  KubernetesVersion:
    Type: String
    Default: 1.30 # Changed from 1.32 to a stable version

  NumberOfWorkerNodes:
    Type: Number
    Default: 2

  WorkerNodesInstanceType:
    Type: String
    Default: t3.medium

  EC2InstanceRoleArn:
    Type: String
    Description: "ARN of the EC2 instance role that needs access to EKS (optional)"
    Default: ""

  AdditionalUserArn:
    Type: String
    Description: "ARN of additional IAM user that needs access to EKS (optional)"
    Default: ""

  AdminRoleArn:
    Type: String
    Description: "ARN of admin role that needs access to EKS (optional)"
    Default: ""

Conditions:
  HasEC2Role: !Not [!Equals [!Ref EC2InstanceRoleArn, ""]]
  HasAdditionalUser: !Not [!Equals [!Ref AdditionalUserArn, ""]]
  HasAdminRole: !Not [!Equals [!Ref AdminRoleArn, ""]]

Resources:

  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref VpcCIDR
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: ThreeTierVPC

  InternetGateway:
    Type: AWS::EC2::InternetGateway

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PublicSubnet1CIDR
      AvailabilityZone: !Select [0, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: PublicSubnet1

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PublicSubnet2CIDR
      AvailabilityZone: !Select [1, !GetAZs '']
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: PublicSubnet2

  PrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PrivateSubnet1CIDR
      AvailabilityZone: !Select [0, !GetAZs '']
      Tags:
        - Key: Name
          Value: PrivateSubnet1

  PrivateSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: !Ref PrivateSubnet2CIDR
      AvailabilityZone: !Select [1, !GetAZs '']
      Tags:
        - Key: Name
          Value: PrivateSubnet2

  NatEIP:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  NATGateway:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatEIP.AllocationId
      SubnetId: !Ref PublicSubnet1
      Tags:
        - Key: Name
          Value: NATGateway

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC

  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachGateway
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnet1RouteTableAssoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet1
      RouteTableId: !Ref PublicRouteTable

  PublicSubnet2RouteTableAssoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet2
      RouteTableId: !Ref PublicRouteTable

  PrivateRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC

  PrivateRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NATGateway

  PrivateSubnet1RouteTableAssoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnet1
      RouteTableId: !Ref PrivateRouteTable

  PrivateSubnet2RouteTableAssoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnet2
      RouteTableId: !Ref PrivateRouteTable

  EksRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ClusterName}-cluster-role-${AWS::AccountId}"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: eks.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"

  EksNodeRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ClusterName}-node-role-${AWS::AccountId}"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
        - "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
        - "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"

  EksConfigLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: EKSConfigPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - eks:DescribeCluster
                  - eks:UpdateClusterConfig
                Resource: !Sub "arn:aws:eks:${AWS::Region}:${AWS::AccountId}:cluster/${ClusterName}"

  EksCluster:
    Type: AWS::EKS::Cluster
    Properties:
      Name: !Ref ClusterName
      Version: !Ref KubernetesVersion
      RoleArn: !GetAtt EksRole.Arn
      ResourcesVpcConfig:
        SubnetIds:
          - !Ref PrivateSubnet1
          - !Ref PrivateSubnet2
          - !Ref PublicSubnet1
          - !Ref PublicSubnet2
        EndpointPrivateAccess: true
        EndpointPublicAccess: true
        PublicAccessCidrs:
          - "0.0.0.0/0"
      Logging:
        ClusterLogging:
          EnabledTypes:
            - Type: api
            - Type: audit

  EksNodeGroup:
    Type: AWS::EKS::Nodegroup
    DependsOn: EksCluster
    Properties:
      ClusterName: !Ref ClusterName
      NodeRole: !GetAtt EksNodeRole.Arn
      Subnets:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      ScalingConfig:
        MinSize: !Ref NumberOfWorkerNodes
        DesiredSize: !Ref NumberOfWorkerNodes
        MaxSize: !Ref NumberOfWorkerNodes
      InstanceTypes:
        - !Ref WorkerNodesInstanceType
      AmiType: AL2_x86_64
      RemoteAccess:
        Ec2SshKey: !Ref KeyPairName

  KeyPairName:
    Type: AWS::EC2::KeyPair::KeyName
    Description: EC2 Key Pair for SSH access to worker nodes
    Default: ""
    ConstraintDescription: Must be the name of an existing EC2 KeyPair

  EksConfigFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ClusterName}-config-function"
      Runtime: python3.9
      Handler: index.handler
      Role: !GetAtt EksConfigLambdaRole.Arn
      Timeout: 300
      Code:
        ZipFile: |
          import boto3
          import json
          import base64
          import cfnresponse
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def handler(event, context):
              try:
                  logger.info(f"Event: {json.dumps(event)}")

                  if event['RequestType'] == 'Delete':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return

                  cluster_name = event['ResourceProperties']['ClusterName']
                  node_instance_role_arn = event['ResourceProperties']['NodeInstanceRoleArn']
                  region = event['ResourceProperties']['Region']
                  additional_users = event['ResourceProperties'].get('AdditionalUsers', [])
                  additional_roles = event['ResourceProperties'].get('AdditionalRoles', [])

                  mapRoles = [
                      {
                          'rolearn': node_instance_role_arn,
                          'username': 'system:node:{{EC2PrivateDNSName}}',
                          'groups': ['system:bootstrappers', 'system:nodes']
                      }
                  ]

                  mapUsers = []

                  for role in additional_roles:
                      if role:
                          mapRoles.append({
                              'rolearn': role,
                              'username': role.split('/')[-1],
                              'groups': ['system:masters']
                          })

                  for user in additional_users:
                      if user:
                          mapUsers.append({
                              'userarn': user,
                              'username': user.split('/')[-1],
                              'groups': ['system:masters']
                          })

                  logger.info("aws-auth configuration prepared successfully")
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                      'Message': 'aws-auth configuration created',
                      'MapRoles': json.dumps(mapRoles),
                      'MapUsers': json.dumps(mapUsers)
                  })

              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {
                      'Error': str(e)
                  })

  EksConfigResource:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: EksNodeGroup
    Properties:
      ServiceToken: !GetAtt EksConfigFunction.Arn
      ClusterName: !Ref ClusterName
      NodeInstanceRoleArn: !GetAtt EksNodeRole.Arn
      Region: !Ref AWS::Region
      AdditionalUsers:
        - !If [HasAdditionalUser, !Ref AdditionalUserArn, ""]
      AdditionalRoles:
        - !If [HasEC2Role, !Ref EC2InstanceRoleArn, ""]
        - !If [HasAdminRole, !Ref AdminRoleArn, ""]

Outputs:

  VPCId:
    Value: !Ref VPC
    Export:
      Name: !Sub "${AWS::StackName}-VPC-ID"

  EKSClusterName:
    Value: !Ref ClusterName
    Export:
      Name: !Sub "${AWS::StackName}-EKS-Cluster-Name"

  EKSClusterArn:
    Value: !GetAtt EksCluster.Arn
    Export:
      Name: !Sub "${AWS::StackName}-EKS-Cluster-Arn"

  EKSClusterEndpoint:
    Value: !GetAtt EksCluster.Endpoint
    Export:
      Name: !Sub "${AWS::StackName}-EKS-Cluster-Endpoint"

  PublicSubnets:
    Value: !Join [",", [!Ref PublicSubnet1, !Ref PublicSubnet2]]
    Export:
      Name: !Sub "${AWS::StackName}-Public-Subnets"

  PrivateSubnets:
    Value: !Join [",", [!Ref PrivateSubnet1, !Ref PrivateSubnet2]]
    Export:
      Name: !Sub "${AWS::StackName}-Private-Subnets"

  NodeGroupName:
    Value: !Ref EksNodeGroup
    Export:
      Name: !Sub "${AWS::StackName}-NodeGroup-Name"

  EKSClusterRoleArn:
    Value: !GetAtt EksRole.Arn
    Export:
      Name: !Sub "${AWS::StackName}-EKS-Cluster-Role-Arn"

  EKSNodeRoleArn:
    Value: !GetAtt EksNodeRole.Arn
    Export:
      Name: !Sub "${AWS::StackName}-EKS-Node-Role-Arn"

  KubectlInstructions:
    Value: !Sub |
      To access this EKS cluster, run:
      aws eks update-kubeconfig --region ${AWS::Region} --name ${ClusterName}

      If you provided additional user/role ARNs, they should have access.
      Otherwise, only the AWS identity that created this stack has access.
    Export:
      Name: !Sub "${AWS::StackName}-Access-Instructions"
